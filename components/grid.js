// Generated by CoffeeScript 1.4.0
(function() {

  define(['underscore', 'coala/coala', 'coala/components/callbacks/grid', 'coala/vendors/jquery/jqgrid/i18n/grid.locale-cn', 'coala/vendors/jquery/jqgrid/jquery.jqGrid.src'], function(_, coala, cbGrid) {
    var buildGrid, delegateGridEvents;
    delegateGridEvents = function(view, obj, options, prefix) {
      var event, events, _i, _len, _results;
      events = ['onSelectRow', 'gridComplete', 'beforeRequest', 'onCellSelect', 'loadBeforeSend', 'loadComplete', 'ondblClickRow', 'onHeaderClick', 'onPaging', 'onRightClickRow', 'onSelectAll', 'onSortCol', 'serializeGridData'];
      _results = [];
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        event = events[_i];
        _results.push((function(event) {
          return options[event] = view.feature.delegateComponentEvent(view, obj, prefix + ':' + event, options[event]);
        })(event));
      }
      return _results;
    };
    coala.registerComponentHandler('grid', (function() {}), function(el, options, view) {
      var defaultOptions, grid, obj, reader;
      defaultOptions = {
        autowidth: options.fit,
        cellLayout: 11,
        viewrecords: true,
        rownumbers: true,
        datatype: 'collection',
        collection: view.collection
      };
      options = _.extend(defaultOptions, options);
      reader = _.extend({
        repeatitems: false
      }, options.jsonReader || {});
      options.jsonReader = reader;
      if (options.pager && _.isString(options.pager)) {
        options.pager = view.$(options.pager);
      }
      obj = {};
      delegateGridEvents(view, obj, options, 'grid');
      if (options.fit) {
        el.addClass('ui-jqgrid-fit');
        cbGrid.resizeToFit(el);
      }
      grid = buildGrid(el, options, view);
      obj.component = grid;
      return grid;
    });
    coala.registerComponentHandler('tree-table', (function() {}), function(el, options, view) {
      var collection, grid, obj, processRecords, reader;
      collection = view.collection;
      options = _.extend({
        ExpandColumn: 'name'
      }, options);
      options.treeGrid = true;
      options.ExpandColumn = 'name';
      options.treeGridModel = 'adjacency';
      processRecords = function(records, parent, level, results) {
        var r, record, rs, _i, _j, _k, _len, _len1, _len2, _ref, _results;
        rs = [];
        if (parent === null) {
          for (_i = 0, _len = records.length; _i < _len; _i++) {
            record = records[_i];
            if (record.parent === null) {
              rs.push(record);
            }
          }
        } else {
          for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
            record = records[_j];
            if (((_ref = record.parent) != null ? _ref.id : void 0) === parent.id) {
              rs.push(record);
            }
          }
        }
        if (rs.length === 0) {
          if (parent) {
            parent.isLeaf = true;
          }
          return;
        }
        _results = [];
        for (_k = 0, _len2 = rs.length; _k < _len2; _k++) {
          r = rs[_k];
          r.level = level;
          r.expanded = false;
          r.loaded = true;
          r.isLeaf = false;
          r.parentId = parent === null ? null : parent.id;
          results.push(r);
          _results.push(processRecords(records, r, level + 1, results));
        }
        return _results;
      };
      if (options.datatype !== 'local') {
        options.datatype = function(data) {
          var op,
            _this = this;
          op = {
            data: data
          };
          if (data.page) {
            op.data['_page'] = data.page;
          }
          if (data.rows) {
            op.data['_pageSize'] = data.rows;
          }
          if (data.sidx) {
            op.data['_order'] = "" + data.sidx + "-" + data.sord;
          }
          delete data.page;
          delete data.rows;
          delete data.sidx;
          delete data.sord;
          return collection.fetch(op).done(function() {
            var records, rs;
            records = collection.toJSON();
            rs = [];
            processRecords(records, null, 0, rs);
            return _this.addJSONData({
              rows: rs,
              total: collection.pageCount,
              page: collection.page
            });
          });
        };
      }
      reader = _.extend({
        repeatitems: false
      }, options.jsonReader || {});
      options.jsonReader = reader;
      reader = _.extend({
        parent_id_field: 'parentId'
      }, options.treeReader || {});
      options.treeReader = reader;
      if (options.pager && _.isString(options.pager)) {
        options.pager = view.$(options.pager);
      }
      obj = {};
      delegateGridEvents(view, obj, options, 'treeTable');
      if (options.fit) {
        el.addClass('ui-jqgrid-fit');
        cbGrid.resizeToFit(el);
      }
      grid = buildGrid(el, options, view);
      obj.component = grid;
      return grid;
    });
    return buildGrid = function(el, options, view) {
      var colModel, data, f, fields, grid, _i, _len;
      fields = options.colModel;
      colModel = [];
      for (_i = 0, _len = fields.length; _i < _len; _i++) {
        f = fields[_i];
        if (f.type === 'enum') {
          data = f.editoptions.value.split(';');
          f.searchoptions = {
            sopt: ['in'],
            dataInit: function(el) {
              var d, _j, _len1, _select;
              _select = $('<select>');
              for (_j = 0, _len1 = data.length; _j < _len1; _j++) {
                d = data[_j];
                _select.append("<option value=" + (d.split(':')[0]) + ">" + (d.split(':')[1]) + "</option>");
              }
              $(el).after(_select);
              $(el).hide();
              _select.css('width', '100%');
              _select.attr('multiple', 'multiple');
              _select.select2();
              return _select.on('change', function() {
                $(el).val(_select.val());
                return $(el).trigger('keydown');
              });
            }
          };
        } else if (f.type === 'date') {
          f.searchoptions = {
            sopt: ['between'],
            dataInit: function(el) {
              return $(el).daterangepicker();
            }
          };
        } else if (f.type === 'number') {
          f.searchoptions = {
            sopt: ['between']
          };
        } else if (f.type === 'boolean') {
          f.stype = 'select';
          f.editoptions = {
            value: ':全部;1:是;0:否'
          };
        } else {
          if (f.stype !== 'select') {
            f.searchoptions = {
              sopt: ['like']
            };
          }
        }
        if (f.name.indexOf('.') !== -1) {
          f.sortable = false;
          f.search = false;
        }
        if (_.isString(f.renderer)) {
          f.formatter = view.bindEventHandler(f.renderer, 'renderers');
        }
        if (_.isString(f.peeler)) {
          f.unformat = view.bindEventHandler(f.peeler, 'renderers');
        }
        colModel.push(f);
      }
      options.colModel = colModel;
      grid = el.jqGrid(options);
      el.jqGrid('filterToolbar', {
        stringResult: true,
        searchOnEnter: false
      });
      return grid;
    };
  });

}).call(this);
